[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Approaching (Many) Vehicle Routing Problems",
    "section": "",
    "text": "Preface\nNote: this is my hobby work in progress.\nMy experience with Vehicle Routing Problems (VRP) dated back to my Ph.D. years when I designed and implemented algorithms to solve the Consistent Vehicle Routing Problem (ConVRP), a variant of the Periodic Vehicle Routing Problem (PVRP) with application in the home healthcare industry. Since routing optimization is ubiquitous in supply chain domain, I’ve also solved various VRP variants since I started working in industry.\nVRP is a classical optimization problem in Operations Research (OR) and there are many solution approaches to attack this problem, mostly depending on the complexity and/or the scale of the problem at hand. In this book (notebook), I intend to document the various approaches to (effectively) solve VRPs. Consider them my secrect sauces for routing optimization.\nAll the algorithms will be implemented in Java, which is my language of choice when implementing optimization algorithms. Although I also use Python extensively in other areas of data scicen work, machine learning in particular, it is too slow to build efficient algorithms that are time-critical.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html#exact-algorithms",
    "href": "intro.html#exact-algorithms",
    "title": "Introduction",
    "section": "Exact algorithms",
    "text": "Exact algorithms\nExact algorithms are of particular interest if we want optimal solutions for our problems at hand. Unfortunately, VRPs are computationall intractable in nature unless the problem in small in scale or possess certain special problem structure. In this section, we will cover several mathematical modeling approaches towards the Traveling Salesman Problem (TSP) and the Capacitate VRP (CVRP).\nMore importantly, we will look into one powerful technique, column generation, that not noly see great success in solving VRPs, but many other optimization problems in general. Column generation is my personal favorite technique in solving VRP in that it is a very flexible framework that in itself can find good solutions, but can also be combined with other algorithms to jointly come up with even better solutions.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#heuristic-and-metaheuristics",
    "href": "intro.html#heuristic-and-metaheuristics",
    "title": "Introduction",
    "section": "Heuristic and metaheuristics",
    "text": "Heuristic and metaheuristics\nWe will mostly look at some constructive heuristics for TSP and VRP. In addition, we will examine how to implement various metaheuristics to solve these problems.\nLarge neighborhood search (LNS) is a popular searching algorithm for VRPs. It’s powering several industry-level routing optimization engines I am aware of. Several other routing engines also utilize Guided Local Search (GLS).",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "intro.html#open-source-routing-solvers",
    "href": "intro.html#open-source-routing-solvers",
    "title": "Introduction",
    "section": "Open source routing solvers",
    "text": "Open source routing solvers\nThe two open source VRP solvers we will check are the Google OR-Tools routing solver and Timefold. Google OR-Tools offers a routing engine that provides routing optimization capabilities out of the box. Once getting used to its modeling syntax, it provides a jump start to solving many VRPs.\nSimilarly, Timefold is a great open source solver for planning and scheduling optimization problems.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "ip-tsp.html#tsp-instances",
    "href": "ip-tsp.html#tsp-instances",
    "title": "1  Traveling Salesman Problem",
    "section": "1.1 TSP Instances",
    "text": "1.1 TSP Instances\nBefore discussing the mathematical models of the TSP, we first provide an introduction to the instances that will be utilized to test various formulations and illustrate the resulting TSP solutions. The TSP is a widely recognized optimization problem that has been studied for several decades. Due to its significance, many benchmarking problem instances of varying sizes are available in literature. In this chapter, we do not aim to solve the most challenging TSP instances, but instead, our objective is to demonstrate how to apply different formulations of the TSP using OR-Tools.\nTo achieve this objective, we will focus on presenting some of the small-sized instances that can be solved effectively using OR-Tools. These instances are well-documented, which makes them easy to understand and implement in practice. Additionally, they help illustrate the optimization techniques used to solve the TSP, such as branch-and-bound and cutting plane methods. Moreover, small-sized instances allow for quicker computation, making it easier to observe the behavior of different algorithms and identify which formulations are most efficient.\nBy presenting a range of examples, we aim to provide a clear understanding of how to implement different TSP formulations using OR-Tools, which can be applied to real-world problems in various domains, such as transportation planning and logistics, network design, and circuit board drilling. Additionally, we aim to demonstrate the advantages and limitations of different TSP formulations and algorithms, highlighting which techniques perform well under specific circumstances. By doing so, readers can gain insight into how to apply TSP optimization techniques to their own problems effectively.\n\n1.1.1 TSPLIB\nThe TSP instances used in this section are sourced from TSPLIB95, a library of TSP benchmark instances. To make it easier to work with these instances, we utilize the tsplib95 Python library, which can be installed using the pip install tsplib95 command.\nIn the code snippet below, we demonstrate how to use the tsplib95 package to load the ulysses22.tsp problem from a data file downloaded from TSPLIB95. The loaded data can be used to formulate and solve TSP instances using OR-Tools or other optimization tools. The full instance data is provided at the end for reference. By leveraging the tsplib95 package, we can quickly and easily access TSP instances for experimentation and analysis, and focus our efforts on the formulation and optimization aspects of the problem.\n\nimport tsplib95\n\n# load problem\nproblem = tsplib95.load('./data/tsp/ulysses22.tsp')\n\n# show instance\nproblem.as_name_dict()\n\n{'name': 'ulysses22.tsp',\n 'comment': 'Odyssey of Ulysses (Groetschel/Padberg)',\n 'type': 'TSP',\n 'dimension': 22,\n 'edge_weight_type': 'GEO',\n 'display_data_type': 'COORD_DISPLAY',\n 'node_coords': {1: [38.24, 20.42],\n  2: [39.57, 26.15],\n  3: [40.56, 25.32],\n  4: [36.26, 23.12],\n  5: [33.48, 10.54],\n  6: [37.56, 12.19],\n  7: [38.42, 13.11],\n  8: [37.52, 20.44],\n  9: [41.23, 9.1],\n  10: [41.17, 13.05],\n  11: [36.08, -5.21],\n  12: [38.47, 15.13],\n  13: [38.15, 15.35],\n  14: [37.51, 15.17],\n  15: [35.49, 14.32],\n  16: [39.36, 19.56],\n  17: [38.09, 24.36],\n  18: [36.09, 23.0],\n  19: [40.44, 13.57],\n  20: [40.33, 14.15],\n  21: [40.37, 14.23],\n  22: [37.57, 22.56]}}\n\n\nThe list of nodes can be retrieved using the get_nodes() function, as shown below.\n\nlist(problem.get_nodes())\n\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n\n\nTo get the distance between any pair of nodes, we use the get_weight() function.\n\nprint(f'distance between node 1 and 2 = {problem.get_weight(1, 2)}')\n\ndistance between node 1 and 2 = 509\n\n\n\n\n1.1.2 Visualize TSP Solution\nIn this section, our goal is to gain a better understanding of the TSP problem by visualizing the optimal solution found for instances provided by TSPLIB95. To achieve this, we define a class called TspVisualizer in our code that is responsible for displaying the route that connects all nodes in a TSP solution. The TspVisualizer class contains a single function, called show(locations, edges), which accepts two input parameters: locations and edges.\nThe locations parameter is a dictionary that contains the mapping between location ID and its corresponding coordinates. The edges parameter is a list of edges that form the TSP tour. By calling the show function with the appropriate input parameters, we can visualize the TSP tour and gain an intuitive understanding of what the TSP problem is trying to accomplish. This visualization can be a helpful tool in understanding how the different TSP formulations and algorithms work, and can aid in identifying potential improvements to the solution. The use of the TspVisualizer class allows for easy visualization of the TSP solution and makes it possible to explore and analyze TSP instances in a more meaningful way.\n\nimport networkx as nx\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nclass TspVisualizer:\n    \"\"\"visualize a TSP tour\n    \"\"\"\n    \n    @staticmethod\n    def show(locations, edges):\n        \"\"\"draw TSP tour\n        adapted from https://stackoverflow.com/a/50682819\n        \n        examples:\n        locations = {\n            0: (5, 5),\n            1: (4, 9),\n            2: (6, 4),\n        }\n\n        edges = [\n            (0, 1),\n            (1, 2),\n            (2, 0),\n        ]\n\n        Args:\n            locations (dict): location id -&gt; (lat, lon)\n            edges (list): list of edges\n        \"\"\"\n        G = nx.DiGraph()\n        G.add_edges_from(edges)\n        plt.figure(figsize=(15,10))\n        \n        colors = mpl.colormaps[\"Set1\"].colors\n        color_idx = 1\n        color = np.array([colors[color_idx]])\n        \n        nx.draw_networkx_nodes(G, \n                                locations, \n                                nodelist=[x[0] \n                                        for x in edges], \n                                node_color=color)\n        nx.draw_networkx_edges(G,\n                                locations, \n                                edgelist=edges,\n                                width=4, \n                                edge_color=color, \n                                style='dashed')\n        \n        # labels\n        nx.draw_networkx_labels(G, locations, \n                                font_color='w', \n                                font_size=12, \n                                font_family='sans-serif')\n\n        #print out the graph\n        plt.axis('off')\n        plt.show()\n\nNow let’s load the optimal solution for the aforementioned instance and show its content below.\n\nsolution = tsplib95.load('./data/tsp/ulysses22.opt.tour')\nsolution.as_name_dict()\n\n{'name': 'ulysses22.opt.tour',\n 'comment': 'Optimal solution of ulysses22 (7013)',\n 'type': 'TOUR',\n 'dimension': 22,\n 'tours': [[1,\n   14,\n   13,\n   12,\n   7,\n   6,\n   15,\n   5,\n   11,\n   9,\n   10,\n   19,\n   20,\n   21,\n   16,\n   3,\n   2,\n   17,\n   22,\n   4,\n   18,\n   8]]}\n\n\nThe code snippet below plots the optimal tour, which is shown in Figure 1.1.\n\nlocations = problem.node_coords\ntour = solution.tours[0]\nedges = []\nfor i in range(len(tour) - 1):\n    edges.append((tour[i], tour[i + 1]))\nedges.append((tour[-1], tour[0]))\nedges = []\nfor i in range(len(tour) - 1):\n    edges.append((tour[i], tour[i + 1]))\nedges.append((tour[-1], tour[0]))\nTspVisualizer.show(locations, edges)\n\n\n\n\n\n\n\nFigure 1.1: Optimal tour of the ulysses22 instance\n\n\n\n\n\nLet’s put this visualization procedure into a dedicated function, as is given below.\n\nimport tsplib95\n\ndef visualize_tsp(instance_name: str):\n    # load problem\n    problem = tsplib95.load(f'./data/tsp/{instance_name}.tsp')\n    solution = tsplib95.load(f'./data/tsp/{instance_name}.opt.tour')\n\n    locations = problem.node_coords\n    tour = solution.tours[0]\n    edges = []\n    for i in range(len(tour) - 1):\n        edges.append((tour[i], tour[i + 1]))\n    edges.append((tour[-1], tour[0]))\n    edges = []\n    for i in range(len(tour) - 1):\n        edges.append((tour[i], tour[i + 1]))\n    edges.append((tour[-1], tour[0]))\n    TspVisualizer.show(locations, edges)\n\nFigure 1.2 and Figure 1.3 show the optimal tours for the berlin52 and pr76 instances, respectively.\n\nvisualize_tsp('berlin52')\n\n\n\n\n\n\n\nFigure 1.2: Optimal tour of the berlin52 instance\n\n\n\n\n\n\nvisualize_tsp('pr76')\n\n\n\n\n\n\n\nFigure 1.3: Optimal tour of the pr76 instance",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Traveling Salesman Problem</span>"
    ]
  },
  {
    "objectID": "ip-tsp.html#problem-description",
    "href": "ip-tsp.html#problem-description",
    "title": "1  Traveling Salesman Problem",
    "section": "1.2 Problem Description",
    "text": "1.2 Problem Description\nLet \\(\\mathcal{G} = (\\mathcal{V}, \\mathcal{A})\\) be an undirected complete graph, where \\(V = \\{1, 2, \\cdots, n\\}\\) represents a set of \\(n\\) cities or vertices, and \\(\\mathcal{A} = \\{(i, j)\\ |\\ i, j \\in \\mathcal{V}, i \\neq j\\}\\) represents the set of edges connecting these cities. The edges in \\(\\mathcal{A}\\) have weights or distances associated with them, \\(c_{ij}\\), representing the distances or costs to travel between pairs of cities.\nThe objective of the TSP is to find the shortest possible closed tour that visits each city in \\(\\mathcal{V}\\) exactly once and returns to the starting city, while obeying the following constraints:\n\nEach city must be visited exactly once: The tour must include all the cities in \\(\\mathcal{V}\\), and each city must be visited exactly once during the tour.\nThe tour must be closed: The last city visited in the tour must be the same as the starting city, forming a closed loop.",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Traveling Salesman Problem</span>"
    ]
  },
  {
    "objectID": "ip-tsp.html#model-1---dfj",
    "href": "ip-tsp.html#model-1---dfj",
    "title": "1  Traveling Salesman Problem",
    "section": "1.3 Model 1 - DFJ",
    "text": "1.3 Model 1 - DFJ\nThe first formulation was proposed by Dantzig, Fulkerson, and Johnson (1954). It uses the following decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\nWe can state the model as follows:\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp1-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp1-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp1-cons2}\\\\\n&\\quad\n\\begin{split}\n    & \\sum_{i, j \\in S, \\ (i, j) \\in \\mathcal{A}} x_{ij} \\leq |S| - 1,\\\\\n    &\\qquad \\forall S \\subset \\mathcal{V}, \\ 2 \\leq |S| \\leq n - 2\n\\end{split}\n\\label{tsp1-cons3}  \\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp1-cons4}\n\\end{align}\\]\nThis specific TSP formulation aims to find the optimal route with the shortest total distance. To ensure that each node is visited exactly once, constraints \\(\\eqref{tsp1-cons1}\\) and \\(\\eqref{tsp1-cons2}\\), also known as degree constraints, are used. Another set of constraints \\(\\eqref{tsp1-cons3}\\), called subtour elimination constraints, ensure that the solution does not contain any subtours. Subtours are smaller cycles within the larger route that violate the requirement of visiting each city exactly once. Two examples of solutions with subtours are shown in figures Figure 1.4 and Figure 1.5. While these solutions satisfy the degree constraints, they violate the subtour elimination constraints. A subtour contains the same number of edges (or arcs) as nodes, so limiting the number of edges to be less than the number of nodes can help to eliminate subtours. Furthermore, because of the presence of degree constraints, subtours with only one node cannot exist, and similarly, subtours with \\(n-1\\) nodes are also impossible. Therefore, it is acceptable to define the subtour elimination constraints only for subtours that contain between 2 and \\(n-2\\) nodes.\n\n\n\n\n\n\nflowchart LR\n    1((1)) --&gt; 2((2))\n    2 --&gt; 3((3))\n    3 --&gt; 4((4))\n    4 --&gt; 7((7))\n    7 --&gt; 1\n    5((5)) --&gt; 6((6))\n    6 --&gt; 5\n\n\n\n\nFigure 1.4: Subtour with 2 nodes\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n    1((1)) --&gt; 2((2))\n    2 --&gt; 3((3))\n    3 --&gt; 7((7))\n    7 --&gt; 1\n    4((4)) --&gt; 5((5)) \n    5 --&gt; 6((6))\n    6 --&gt; 4\n\n\n\n\nFigure 1.5: Subtour with 3 nodes\n\n\n\n\n\nAn equivalent way of constraints \\(\\eqref{tsp1-cons3}\\) is\n\\[\\begin{align}\n    \\sum_{i \\in S}\\sum_{j \\notin S} x_{ij} \\geq 1, \\ \\forall S \\subset \\mathcal{V}, \\ 2 \\leq |S| \\leq n - 2 \\label{tsp1-cons5}\n\\end{align}\\]\nTo understand this, observe that the value of \\(|S|\\) can be calculated as the sum of two terms: the sum of the decision variables \\(x_{ij}\\) for all edges \\((i,j)\\) that are included in the subset, and the sum of the decision variables \\(x_{ij}\\) for all edges that cross the boundary of the subtour, that is, \\(|S| = \\sum_{i, j \\in S, \\ (i, j) \\in \\mathcal{A}} x_{ij} + \\sum_{i \\in S}\\sum_{j \\notin S} x_{ij}\\). This means that the constraints \\(\\eqref{tsp1-cons3}\\) and \\(\\eqref{tsp1-cons5}\\) are interchangeable, as they represent the same condition in different forms.\nTo simplify the implementation of different TSP formulations that will be presented in the following sections, we have created a base class called TspModel in the code below. This class contains the instance information that needs to be solved, as well as several helper functions. Within the class definition, the attribute _node_list holds the list of nodes that must be visited by the TSP tour. The attribute _node_coords is a dictionary that stores the location information for each node. Finally, the attribute _distance is another dictionary that provides the distance between any pair of nodes. The read_inputs() function, defined between lines 15 and 31, takes a TSP problem instance and extracts the necessary information for solving the problem later. The get_combinations() function, defined between lines 33 and 34, generates all possible combinations of nodes with the specified size.\n\nfrom typing import Dict, List\nfrom itertools import combinations\nimport tsplib95\n\nclass TspModel:\n    \"\"\"base class for TSP models\n    \"\"\"\n    \n    def __init__(self, name: str):\n        self._name: str = name\n        self._node_list: List[int] = None\n        self._node_coords: Dict[int, List[float, float]] = None\n        self._distance: Dict[int, Dict[int, int]] = None\n        \n    def read_inputs(self, instance_file: str) -&gt; None:\n        problem = tsplib95.load(instance_file)\n\n        node_coords = problem.node_coords\n        self._node_coords = {\n            id: node_coords[id]\n            for id in node_coords\n        }\n        self._node_list = list(node_coords.keys())\n        \n        self._distance = {}\n        for i in self._node_list:\n            dist = {\n                j: problem.get_weight(i, j)\n                for j in self._node_list\n            }\n            self._distance[i] = dist\n\n    def get_combinations(self, size):\n        return list(combinations(self._node_list, size))\n        \n    @property\n    def name(self): return self._name\n    \n    @property\n    def num_nodes(self): return len(self._node_coords)\n\nTo implement the TSP model using OR-Tools, we define the TspModelV1 class that inherits from the base class TspModel. The constructor initializes a solver object and defines attributes to store decision variables and the optimal solution. The _create_variables() function creates binary decision variables for every arc in the problem, while the _create_objective() function calculates the total traveling cost. Degree constraints are defined in the _create_degree_constraints() function, while the subtour elimination constraints are defined in the _create_subtour_elimination_constraints() function. The build_model() function needs to be called before optimize() to construct the model.\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV1(TspModel):\n    \n    def __init__(self, name='Tspmodel_v1'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar('x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n    \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        num_nodes = self.num_nodes\n        for size in range(2, num_nodes - 1):\n            combinations = self.get_combinations(size)\n            for comb in combinations:\n                expr = [self._var_x[i][j]\n                        for i, j in product(comb, comb)\n                        if i != j]\n                self._solver.Add(self._solver.Sum(expr) &lt;= \n                                len(comb) - 1)\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\nNow we use the TspModelV1 class to solve the burma14 instance and plots the optimal solution found by the OR-Tools in Figure 1.6.\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v1 = TspModelV1()\nmodel_v1.read_inputs(instance_file=instance)\nmodel_v1.build_model()\nmodel_v1.show_model_info()\nmodel_v1.optimize(False)\nmodel_v1.show_opt_route()\n\nNumber of variables: 182\nNumber of constraints: 16382\noptimal value = 3323.00\n\n\n\n\n\n\n\n\nFigure 1.6: Optimal route for the burma14 instance",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Traveling Salesman Problem</span>"
    ]
  },
  {
    "objectID": "ip-tsp.html#model-2---mtz",
    "href": "ip-tsp.html#model-2---mtz",
    "title": "1  Traveling Salesman Problem",
    "section": "1.4 Model 2 - MTZ",
    "text": "1.4 Model 2 - MTZ\nIn this formulation, an alternative way of modeling the subtour elimination constraints was proposed by Miller, Tucker, and Zemlin (1960). The model uses two types of decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\\(u_i\\): a continuous variable for \\(i \\in \\mathcal{V} \\backslash \\{1\\}\\)\n\nThe complete formulation is given below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp2-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp2-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp2-cons2}\\\\\n&\\quad\n\\begin{split}\n    &u_i - u_j + (n - 1) x_{ij} \\leq n - 2, \\\\\n    &\\qquad \\forall i, j \\in \\{2, \\cdots, n\\}, i \\neq j\n\\end{split}\n\\label{tsp2-cons3} \\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp2-cons4} \\\\\n&\\quad 1 \\leq n_i \\leq n - 1, i = 2, \\cdots, n \\label{tsp2-cons5}\n\\end{align}\\]\nIn this formulation, constraints \\(\\eqref{tsp2-cons1}\\) and \\(\\eqref{tsp2-cons2}\\) serve as the degree constraints requiring that there is only one arc entering and leaving a node. Constraints \\(\\eqref{tsp2-cons3}\\) are the new subtour elimination constraints. To see how constraints \\(\\eqref{tsp2-cons3}\\) effectively forbid subtours, let’s examine the example below in Figure 1.7. In the figure, nodes 5 and 6 form a subtour and constraints \\(\\eqref{tsp2-cons3}\\) become:\n\\[\\begin{align}\nu_5 - u_6 + (7 - 1) * 1 \\leq 7 - 2 \\\\\nu_6 - u_5 + (7 - 1) * 1 \\leq 7 - 2\\\\\n\\end{align}\\]\nwhich translate to:\n\\[\\begin{align}\nu_5 \\leq u_6 - 1 \\\\\nu_6 \\leq u_5 - 1\n\\end{align}\\]\nand thus:\n\\[\\begin{align}\n    u_5 & \\leq u_6 - 1 \\\\\n    & \\leq u_5 - 1 - 1\\\\\n    & \\leq u_5 - 2\n\\end{align}\\]\nfor which, we have \\(0 \\leq -2\\), which is obviously wrong. Therefore, any subtour will violate the constraints defined in \\(\\eqref{tsp2-cons3}\\).\n\n\n\n\n\n\nflowchart LR\n    1((1)) --&gt; 2((2))\n    2 --&gt; 3((3))\n    3 --&gt; 7((7))\n    7 --&gt; 4((4))\n    4 --&gt; 1\n    5((5)) --&gt; 6((6))\n    6 --&gt; 5\n\n\n\n\nFigure 1.7: Subtour with 2 nodes\n\n\n\n\n\nThe code below gives the complete program of the formulation. The new variable \\(u_i\\) is defined in function _create_variables() and the subtour elimination constraints are updated in function _create_subtour_elimination_constraints().\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV2(TspModel):\n    \n    def __init__(self, name='Tspmodel_v2'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_u = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar(f'x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        self._var_u = {\n            i: self._solver.NumVar(1, self.num_nodes, f'v_{i}')\n            for i in self._node_list\n            if i != 1\n        }\n    \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        num_nodes = self.num_nodes\n        for i, j in product(self._node_list, self._node_list):\n            if i == j: continue\n            if i == 1 or j == 1: continue\n            self._solver.Add(self._var_u[i] - \n                            self._var_u[j] +\n                            (num_nodes - 1) * self._var_x[i][j] &lt;=\n                            num_nodes - 2)\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\nWe now use this formulation to solve the burma14 instance and show its optimal solution in Figure 1.8.\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v2 = TspModelV2()\nmodel_v2.read_inputs(instance_file=instance)\nmodel_v2.build_model()\nmodel_v2.show_model_info()\nmodel_v2.optimize(False)\nmodel_v2.show_opt_route()\n\nNumber of variables: 195\nNumber of constraints: 184\noptimal value = 3323.00\n\n\n\n\n\n\n\n\nFigure 1.8: Optimal route for the burma14 instance\n\n\n\n\n\nFigure 1.9 shows the optimal solution found by the formulation for the ulysses22 instance.\n\ninstance = './data/tsp/ulysses22.tsp'\n\nmodel_v2 = TspModelV2()\nmodel_v2.read_inputs(instance_file=instance)\nmodel_v2.build_model()\nmodel_v2.show_model_info()\nmodel_v2.optimize(False)\nmodel_v2.show_opt_route()\n\nNumber of variables: 483\nNumber of constraints: 464\noptimal value = 7013.00\n\n\n\n\n\n\n\n\nFigure 1.9: Optimal route for the ulysses22 instance",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Traveling Salesman Problem</span>"
    ]
  },
  {
    "objectID": "ip-tsp.html#model-3---single-commodity-flow",
    "href": "ip-tsp.html#model-3---single-commodity-flow",
    "title": "1  Traveling Salesman Problem",
    "section": "1.5 Model 3 - Single Commodity Flow",
    "text": "1.5 Model 3 - Single Commodity Flow\nThe model uses two types of decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\\(y_{ij}\\): a continuous variable representing the flow on arc \\((i, j) \\in \\mathcal{A}\\)\n\nThe complete formulation is given below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp3-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp3-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp3-cons2}\\\\\n&\\quad y_{ij} \\leq (n - 1) x_{ij}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp3-cons3} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V}\\backslash \\{1\\}} y_{1j} = n - 1, \\label{tsp3-cons4} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}\\backslash \\{j\\}} y_{ij} - \\sum_{k \\in \\mathcal{V}\\backslash \\{j\\}} y_{jk} = 1, \\ \\forall j \\in \\mathcal{V}\\backslash \\{1\\} \\label{tsp3-cons5}\\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp3-cons6} \\\\\n&\\quad y_{ij} \\geq 0, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp3-cons7}\n\\end{align}\\]\nIn this formulation, the constraints \\(\\eqref{tsp3-cons3}\\) - \\(\\eqref{tsp3-cons5}\\) are the subtour elimination constraints. Specifically, constraints \\(\\eqref{tsp3-cons3}\\) make sure that the amount of flow on any arc \\((i, j)\\) is at most \\(n - 1\\) when the arc is active. Constraints \\(\\eqref{tsp3-cons4}\\) state that there is a total of \\(n - 1\\) flowing out of the source node 1. Constraints \\(\\eqref{tsp3-cons5}\\) require that the incoming flow is 1 unit bigger than the outgoing flow at any node other than the source node 1. To see how this prevents subtours, we’ll use Figure 1.10 as an example.\n\n\n\n\n\n\nflowchart LR\n    1((1)) -- 5 --&gt; 2((2))\n    2 -- 4 --&gt; 3((3))\n    3 -- 4 --&gt; 4((4))\n    4 -- 2 --&gt; 1\n    5((5)) -- v --&gt; 6((6))\n    6 --w--&gt; 5\n\n\n\n\nFigure 1.10: Subtour with 2 nodes\n\n\n\n\n\nAccording to constraints \\(\\eqref{tsp3-cons4}\\), we have the following relations:\n\\[\\begin{align}\n    v - w = 1 \\\\\n    w - v = 1\n\\end{align}\\]\nSumming them together leads to \\(0 = 2\\), which is clearly false.\nThe code below gives the complete implementation of this formulation.\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV3(TspModel):\n    \n    def __init__(self, name='Tspmodel_v3'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_y = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar(f'x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        infinity = self._solver.Infinity()\n        self._var_y = {}\n        for i in self._node_list:\n            self._var_y[i] = {\n                j: self._solver.NumVar(0, infinity, f'y_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        num_nodes = self.num_nodes\n        for i, j in product(self._node_list, self._node_list):\n            if i == j: continue\n            self._solver.Add(\n                self._var_y[i][j] &lt;= \n                (num_nodes - 1) * self._var_x[i][j])\n\n        expr = [self._var_y[1][j] for j in self._node_list if j != 1]\n        self._solver.Add(self._solver.Sum(expr) == num_nodes - 1)\n\n        for j in self._node_list:\n            if j == 1: continue\n            expr1 = [self._var_y[i][j] \n                    for i in self._node_list if i != j]\n            expr2 = [self._var_y[j][k]\n                     for k in self._node_list if k != j]\n            self._solver.Add(\n                self._solver.Sum(expr1) - \n                self._solver.Sum(expr2) == 1)\n        \n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\nFigure 1.11 shows the optimal soution for instance burma14 found by this formulation.\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v3 = TspModelV3()\nmodel_v3.read_inputs(instance_file=instance)\nmodel_v3.build_model()\nmodel_v3.show_model_info()\nmodel_v3.optimize(False)\nmodel_v3.show_opt_route()\n\nNumber of variables: 364\nNumber of constraints: 224\noptimal value = 3323.00\n\n\n\n\n\n\n\n\nFigure 1.11: Optimal route for the burma14 instance\n\n\n\n\n\nFigure 1.12 shows the optimal route found by the formulation for the instance ulysses22.\n\ninstance = './data/tsp/ulysses22.tsp'\n\nmodel_v3 = TspModelV3()\nmodel_v3.read_inputs(instance_file=instance)\nmodel_v3.build_model()\nmodel_v3.show_model_info()\nmodel_v3.optimize(False)\nmodel_v3.show_opt_route()\n\nNumber of variables: 924\nNumber of constraints: 528\noptimal value = 7013.00\n\n\n\n\n\n\n\n\nFigure 1.12: Optimal route for the ulysses22 instance\n\n\n\n\n\nFigure 1.13 gives the optimal solution of instance berlin52.\n\ninstance = './data/tsp/berlin52.tsp'\n\nmodel_v3 = TspModelV3()\nmodel_v3.read_inputs(instance_file=instance)\nmodel_v3.build_model()\nmodel_v3.show_model_info()\nmodel_v3.optimize(False)\nmodel_v3.show_opt_route()\n\nNumber of variables: 5304\nNumber of constraints: 2808\noptimal value = 7542.00\n\n\n\n\n\n\n\n\nFigure 1.13: Optimal route for the berlin52 instance\n\n\n\n\n\nFigure 1.14 shows the optimal solution for instance pr16.\n\ninstance = './data/tsp/pr76.tsp'\n\nmodel_v3 = TspModelV3()\nmodel_v3.read_inputs(instance_file=instance)\nmodel_v3.build_model()\nmodel_v3.show_model_info()\nmodel_v3.optimize(False)\nmodel_v3.show_opt_route()\n\nNumber of variables: 11400\nNumber of constraints: 5928\noptimal value = 108159.00\n\n\n\n\n\n\n\n\nFigure 1.14: Optimal route for the pr76 instance",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Traveling Salesman Problem</span>"
    ]
  },
  {
    "objectID": "ip-tsp.html#model-4---two-commodity-flow",
    "href": "ip-tsp.html#model-4---two-commodity-flow",
    "title": "1  Traveling Salesman Problem",
    "section": "1.6 Model 4 - Two Commodity Flow",
    "text": "1.6 Model 4 - Two Commodity Flow\nThe model uses three types of decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\\(y_{ij}\\): a continuous variable representing the flow of commodity 1 on arc \\((i, j) \\in \\mathcal{A}\\)\n\\(z_{ij}\\): a continuous variable representing the flow of commodity 2 on arc \\((i, j) \\in \\mathcal{A}\\)\n\nThe complete formulation is given below.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp4-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp4-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp4-cons2}\\\\\n&\\quad \\sum_{j \\in \\mathcal{V}\\backslash\\{1\\}} (y_{1j} - y_{j1}) = n - 1 \\label{tsp4-cons3} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V}, j \\neq i} (y_{ij} - y_{ji}) = -1, \\ \\forall i \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp4-cons4} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V}\\backslash\\{1\\}} (z_{1j} - z_{j1}) = -(n - 1) \\label{tsp4-cons5} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V}, j \\neq i} (z_{ij} - z_{ji}) = 1, \\ \\forall i \\in \\mathcal{V} \\backslash \\{1\\}  \\label{tsp4-cons6}\\\\\n&\\quad \\sum_{j \\in \\mathcal{V} , j \\neq i} (y_{ij} + z_{ij}) = n - 1, \\ \\forall i \\in \\mathcal{V}  \\label{tsp4-cons7}\\\\\n&\\quad y_{ij} + z_{ij} = (n - 1) x_{ij}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp4-cons8} \\\\\n&\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp4-cons9} \\\\\n&\\quad y_{ij} \\geq 0, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp4-cons10}  \\\\\n&\\quad z_{ij} \\geq 0, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp4-cons11}\n\\end{align}\\]\nIn this formulation, constraints \\(\\eqref{tsp4-cons3}\\) - \\(\\eqref{tsp4-cons8}\\) together serve as the subtour elimination constraints. To better understand the two commodity flow formulation, we’ll use Figure 1.15 as an example. At the source node 1, there is \\(n-1\\) units of commodity 1 leaving the node and there is no unit of commodity 2 leaving it. At each subsequent node, the amount of commodity 1 decreases by 1 unit while the amount of commodity 2 increases by 1 unit. On any arc in the tour, the total amount of commodities is always \\(n - 1\\).\n\n\n\n\n\n\nflowchart LR\n    1((1)) -- c1: 3, c2:0 --&gt; 2((2))\n    2 -- c1: 2, c2:1 --&gt; 3((3))\n    3 -- c1: 1, c2:2 --&gt; 4((4))\n    4 -- c1: 0, c2:3 --&gt; 1\n\n\n\n\nFigure 1.15: Two commodities flowing on the tour\n\n\n\n\n\nThe code below gives the complete implementation of the two commodity flow formulation.\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV4(TspModel):\n    \n    def __init__(self, name='Tspmodel_v4'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_y = None\n        self._var_z = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar(f'x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        infinity = self._solver.Infinity()\n        self._var_y = {}\n        for i in self._node_list:\n            self._var_y[i] = {\n                j: self._solver.NumVar(0, infinity, f'y_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        self._var_z = {}\n        for i in self._node_list:\n            self._var_z[i] = {\n                j: self._solver.NumVar(0, infinity, f'z_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        num_nodes = self.num_nodes\n        expr1 = [self._var_y[1][j] \n                for j in self._node_list \n                if j != 1]\n        expr2 = [self._var_y[j][1] \n                for j in self._node_list \n                if j != 1]\n        self._solver.Add(\n            self._solver.Sum(expr1) - \n            self._solver.Sum(expr2) == \n            num_nodes - 1)\n\n        for i in self._node_list:\n            if i == 1: continue\n            expr1 = [self._var_y[i][j] \n                    for j in self._node_list \n                    if j != i]\n            expr2 = [self._var_y[j][i] \n                    for j in self._node_list \n                    if j != i]\n            self._solver.Add(\n                self._solver.Sum(expr1) - \n                self._solver.Sum(expr2) == \n                -1)\n            \n        expr1 = [self._var_z[1][j] \n                for j in self._node_list \n                if j != 1]\n        expr2 = [self._var_z[j][1] \n                for j in self._node_list \n                if j != 1]\n        self._solver.Add(\n            self._solver.Sum(expr1) - \n            self._solver.Sum(expr2) == \n            -num_nodes + 1)\n\n        for i in self._node_list:\n            if i == 1: continue\n            expr1 = [self._var_z[i][j] \n                    for j in self._node_list \n                    if j != i]\n            expr2 = [self._var_z[j][i] \n                    for j in self._node_list \n                    if j != i]\n            self._solver.Add(\n                self._solver.Sum(expr1) - \n                self._solver.Sum(expr2) == \n                1)\n        \n        for i in self._node_list:\n            expr1 = [self._var_y[i][j] \n                    for j in self._node_list \n                    if j != i]\n            expr2 = [self._var_z[i][j] \n                    for j in self._node_list \n                    if j != i]\n            self._solver.Add(\n                self._solver.Sum(expr1) + \n                self._solver.Sum(expr2) == \n                num_nodes - 1)\n        \n        for i, j in product(self._node_list, self._node_list):\n            if i == j: continue\n            self._solver.Add(\n                self._var_y[i][j] + \n                self._var_z[i][j] == \n                (num_nodes - 1) * \n                self._var_x[i][j])\n        \n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\nFigure 1.16 shows the optimals solution identified by the formulation for instance burma14.\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v4 = TspModelV4()\nmodel_v4.read_inputs(instance_file=instance)\nmodel_v4.build_model()\nmodel_v4.show_model_info()\nmodel_v4.optimize(False)\nmodel_v4.show_opt_route()\n\nNumber of variables: 546\nNumber of constraints: 252\noptimal value = 3323.00\n\n\n\n\n\n\n\n\nFigure 1.16: Optimal route for the burma14 instance\n\n\n\n\n\nFigure 1.17 gives the optimal solution of the ulysses22 instance.\n\ninstance = './data/tsp/ulysses22.tsp'\n\nmodel_v4 = TspModelV4()\nmodel_v4.read_inputs(instance_file=instance)\nmodel_v4.build_model()\nmodel_v4.show_model_info()\nmodel_v4.optimize(False)\nmodel_v4.show_opt_route()\n\nNumber of variables: 1386\nNumber of constraints: 572\noptimal value = 7013.00\n\n\n\n\n\n\n\n\nFigure 1.17: Optimal route for the ulysses22 instance\n\n\n\n\n\nFigure 1.18 shows the optimals solution identified by the formulation for instance berlin52.\n\ninstance = './data/tsp/berlin52.tsp'\n\nmodel_v4 = TspModelV4()\nmodel_v4.read_inputs(instance_file=instance)\nmodel_v4.build_model()\nmodel_v4.show_model_info()\nmodel_v4.optimize(False)\nmodel_v4.show_opt_route()\n\nNumber of variables: 7956\nNumber of constraints: 2912\noptimal value = 7542.00\n\n\n\n\n\n\n\n\nFigure 1.18: Optimal route for the berlin52 instance",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Traveling Salesman Problem</span>"
    ]
  },
  {
    "objectID": "ip-tsp.html#model-5---multi-commodity-flow",
    "href": "ip-tsp.html#model-5---multi-commodity-flow",
    "title": "1  Traveling Salesman Problem",
    "section": "1.7 Model 5 - Multi-Commodity Flow",
    "text": "1.7 Model 5 - Multi-Commodity Flow\nThe model uses two types of decision variables:\n\n\\(x_{ij}\\): a binary variable that equals 1 if arc \\((i, j) \\in \\mathcal{A}\\) shows up in the optimal solution, 0 otherwise\n\\(y_{ij}^k\\): a continuous variable representing the flow of commodity \\(k\\) on arc \\((i, j) \\in \\mathcal{A}\\), \\(k \\in \\mathcal{V} \\backslash \\{1\\}\\)\n\nThe complete formulation of the problem is presented below. To understand this formulation, let’s imagine that node 1 is the source node in the graph, and each of the remaining nodes demands one unit of different commodities. For instance, node 2 requires one unit of commodity 2, node 3 requires one unit of commodity 3, and so on. The problem can then be expressed as finding the most cost-effective graph that can handle the flow of all \\(n-1\\) commodities. Constraints \\(\\eqref{tsp5-cons1}\\) and \\(\\eqref{tsp5-cons2}\\) are the same as in other formulations. Constraints \\(\\eqref{tsp5-cons3}\\) state that the arc connecting nodes (i,j) must be active to allow any commodity flow, essentially acting as a capacity constraint that limits the flow on the arc. Constraints \\(\\eqref{tsp5-cons4}\\) indicate that exactly one unit of each commodity k flows out of the source node 1. Constraints \\(\\eqref{tsp5-cons5}\\) require that no commodity flows into the source node 1. Constraints \\(\\eqref{tsp5-cons6}\\) ensure that one unit of commodity k flows into node k, and constraints \\(\\eqref{tsp5-cons7}\\) require that there is no flow of commodity k out of node k. Finally, constraints \\(\\eqref{tsp5-cons8}\\) are flow conservation constraints that guarantee that the incoming flow is equal to the outgoing flow at all nodes except the source node for every commodity k.\n\\[\\begin{align}\n\\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{tsp5-obj} \\\\\n\\text{s.t.} &\\quad \\sum_{j \\in \\mathcal{V},\\  j \\neq i} x_{ij} = 1, \\ \\forall i \\in \\mathcal{V} \\label{tsp5-cons1} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V}, \\ i \\neq j} x_{ij} = 1, \\ \\forall j \\in \\mathcal{V} \\label{tsp5-cons2}\\\\\n&\\quad y_{ij}^k \\leq x_{ij}, \\ \\forall (i, j) \\in \\mathcal{A}, k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons3}\\\\\n&\\quad \\sum_{j \\in \\mathcal{V} \\backslash \\{1\\}} y_{1j}^k = 1, \\ \\forall k \\in \\mathcal{V} \\backslash \\{1\\}  \\label{tsp5-cons4} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V} \\backslash \\{1\\}} y_{j1}^k = 0, \\ \\forall k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons5} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V} \\backslash \\{k\\}} y_{jk}^k = 1, \\ \\forall k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons6} \\\\\n&\\quad \\sum_{j \\in \\mathcal{V} \\backslash \\{k\\}} y_{kj}^k = 0, \\ \\forall k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons7} \\\\\n&\\quad \\sum_{i \\in \\mathcal{V} \\backslash \\{j\\}} y_{ij}^k - \\sum_{i \\in \\mathcal{V} \\backslash \\{j\\}} y_{ji}^k = 0, \\ \\forall j, k \\in \\mathcal{V} \\backslash \\{1\\}, j \\neq k \\label{tsp5-cons8} \\\\\n&\\quad x_{ij} = \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{tsp5-cons9}\\\\\n&\\quad y_{ij} \\geq 0, \\ \\forall (i, j) \\in \\mathcal{A}, k \\in \\mathcal{V} \\backslash \\{1\\} \\label{tsp5-cons10}\n\\end{align}\\]\n\nfrom itertools import product\nfrom ortools.linear_solver import pywraplp\n\nclass TspModelV5(TspModel):\n    \n    def __init__(self, name='Tspmodel_v5'):\n        super().__init__(name)\n        \n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_y = None\n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_route = None\n    \n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_degree_constraints()\n        self._create_subtour_elimination_constraints()\n    \n    def optimize(self, enable_output: bool):\n        if enable_output: self._solver.EnableOutput()\n        status = self._solver.Solve()\n        if status is pywraplp.Solver.OPTIMAL:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_route()\n    \n    def _create_variables(self):\n        self._var_x = {}\n        for i in self._node_list:\n            self._var_x[i] = {\n                j: self._solver.BoolVar(f'x_{i, j}')\n                for j in self._node_list\n                if j != i\n            }\n        \n        infinity = self._solver.Infinity()\n        self._var_y = {}\n        for k in self._node_list[1:]:\n            vars = {}\n            for i in self._node_list:\n                vars[i] = {\n                    j: self._solver.NumVar(0, infinity, f'y_{i, j}')\n                    for j in self._node_list\n                    if j != i\n                }\n            self._var_y[k] = vars\n        \n    def _create_objective(self):\n        node_list = self._node_list\n        expr = [self._distance[i][j] * self._var_x[i][j]\n                for i, j in product(node_list, node_list)\n                if i != j]\n        self._solver.Minimize(self._solver.Sum(expr))\n        \n    def _create_degree_constraints(self):\n        for i in self._node_list:\n            out_expr = [self._var_x[i][j]\n                    for j in self._node_list\n                    if j != i\n                    ]\n            in_expr = [self._var_x[j][i]\n                        for j in self._node_list\n                        if j != i\n                    ]\n            self._solver.Add(self._solver.Sum(out_expr) == 1)\n            self._solver.Add(self._solver.Sum(in_expr) == 1)\n    \n    def _create_subtour_elimination_constraints(self):\n        for k in self._node_list[1:]:\n            for i, j in product(self._node_list, self._node_list):\n                if i == j: continue\n                self._solver.Add(self._var_y[k][i][j] &lt;= self._var_x[i][j])\n        \n        for k in self._node_list[1:]:\n            expr = [self._var_y[k][1][j]\n                    for j in self._node_list\n                    if j != 1]\n            self._solver.Add(self._solver.Sum(expr) == 1)\n            \n            expr = [self._var_y[k][j][1]\n                    for j in self._node_list\n                    if j != 1]\n            self._solver.Add(self._solver.Sum(expr) == 0)\n            \n            expr = [self._var_y[k][j][k]\n                    for j in self._node_list\n                    if j != k]\n            self._solver.Add(self._solver.Sum(expr) == 1)\n\n            expr = [self._var_y[k][k][j]\n                    for j in self._node_list\n                    if j != k]\n            self._solver.Add(self._solver.Sum(expr) == 0)\n\n        for j, k in product(self._node_list[1:], \n                            self._node_list[1:]):\n            if j == k: continue\n            expr1 = [self._var_y[k][i][j]\n                    for i in self._node_list\n                    if i != j]\n            expr2 = [self._var_y[k][j][i]\n                    for i in self._node_list\n                    if i != j]\n            self._solver.Add(self._solver.Sum(expr1) == \n                            self._solver.Sum(expr2))\n        \n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = float(self._solver.Objective().Value())\n        self._opt_x = {}\n        for i in self._node_list:\n            self._opt_x[i] = {\n                j: round(self._var_x[i][j].solution_value())\n                for j in self._node_list\n                if j != i\n            }\n            \n        print(f'optimal value = {self._opt_obj:.2f}')\n    \n    def _retrieve_opt_route(self):\n        self._opt_route = []\n        route_start = list(self._opt_x.keys())[0]\n        edge_start = route_start\n        while True:\n            for n in self._opt_x[edge_start]:\n                if self._opt_x[edge_start][n] == 0: continue\n                \n                edge_end = n\n                self._opt_route.append((edge_start, edge_end))\n                break\n            \n            if edge_end == route_start: break\n            edge_start = edge_end\n            \n    def show_opt_route(self):\n        TspVisualizer.show(self._node_coords, self._opt_route)\n        \n        \n    def show_model_info(self):\n        print(f\"Number of variables: {self._solver.NumVariables()}\")\n        print(f\"Number of constraints: {self._solver.NumConstraints()}\")\n\n\ninstance = './data/tsp/burma14.tsp'\n\nmodel_v5 = TspModelV5()\nmodel_v5.read_inputs(instance_file=instance)\nmodel_v5.build_model()\nmodel_v5.show_model_info()\nmodel_v5.optimize(False)\nmodel_v5.show_opt_route()\n\nNumber of variables: 2548\nNumber of constraints: 2602\noptimal value = 3323.00\n\n\n\n\n\n\n\n\nFigure 1.19: Optimal route for the burma14 instance\n\n\n\n\n\n\ninstance = './data/tsp/ulysses22.tsp'\n\nmodel_v5 = TspModelV5()\nmodel_v5.read_inputs(instance_file=instance)\nmodel_v5.build_model()\nmodel_v5.show_model_info()\nmodel_v5.optimize(False)\nmodel_v5.show_opt_route()\n\nNumber of variables: 10164\nNumber of constraints: 10250\noptimal value = 7013.00\n\n\n\n\n\n\n\n\nFigure 1.20: Optimal route for the ulysses22 instance\n\n\n\n\n\n\ninstance = './data/tsp/berlin52.tsp'\n\nmodel_v5 = TspModelV5()\nmodel_v5.read_inputs(instance_file=instance)\nmodel_v5.build_model()\nmodel_v5.show_model_info()\nmodel_v5.optimize(False)\nmodel_v5.show_opt_route()\n\nNumber of variables: 137904\nNumber of constraints: 138110\noptimal value = 7542.00\n\n\n\n\n\n\n\n\nFigure 1.21: Optimal route for the berlin52 instance",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Traveling Salesman Problem</span>"
    ]
  },
  {
    "objectID": "ip-tsp.html#performance-comparison",
    "href": "ip-tsp.html#performance-comparison",
    "title": "1  Traveling Salesman Problem",
    "section": "1.8 Performance Comparison",
    "text": "1.8 Performance Comparison\nWe give in Table 1.1 the computational times required to find the optimal solutions for different instances. It is by no means a thorough or comprehensive performance comparison, as it is only based on one run and on a few instances. It can be seen from the table that the single commodity flow formulation seems to perform the best among all the five formulations.\n\n\n\n\nTable 1.1: Computational time comparison of the five formulations\n\n\n\n\n\n\nInstance\nModel 1\nModel 2\nModel 3\nModel 4\nModel 5\n\n\n\n\nburma14\n2.9s\n0.4s\n0.2s\n0.6s\n0.3s\n\n\nulysses22\n-\n7m25s\n7.2s\n19.8s\n2.8s\n\n\nberlin52\n-\n-\n8.6s\n13.8s\n18m23s\n\n\npr76\n-\n-\n10m51s\n-\n-\n\n\n\n\n\n\n\n\n\n\n\n\nDantzig, G., R. Fulkerson, and S. Johnson. 1954. “Solution of a Large-Scale Traveling-Salesman Problem.” Journal of the Operations Research Society of America 2 (4): 393–410. https://doi.org/10.1287/opre.2.4.393.\n\n\nMiller, C. E., A. W. Tucker, and R. A. Zemlin. 1960. “Integer Programming Formulation of Traveling Salesman Problems.” Journal of the ACM 7 (4): 326–29. https://doi.org/10.1145/321043.321046.",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Traveling Salesman Problem</span>"
    ]
  },
  {
    "objectID": "ip-cvrp.html#cvrp-instances",
    "href": "ip-cvrp.html#cvrp-instances",
    "title": "2  Capacitated Vehicle Routing Problem",
    "section": "2.1 CVRP Instances",
    "text": "2.1 CVRP Instances\nWe use the instances taken from CVRPLIB (2014) to illustrate the modeling and solving process with Google OR-Tools. CVRPLIB (2014) contains many benchmarking instances for CVRP and we use the python package vrplib to load the instance P-n16-k8.vrp and its optimal solution P-n16-k8.sol.\n\n# install vrplib with command: pip install vrplib\nimport vrplib\n\n# Read VRPLIB formatted instances (default)\ninstance = vrplib.read_instance(\"./data/cvrp/P-n16-k8.vrp\")\nsolution = vrplib.read_solution(\"./data/cvrp/P-n16-k8.sol\")\n\nLet’s first create a function to visualize vehicle routes, as given below.\n\nimport networkx as nx\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\ndef show_vehicle_routes(locations, edges):\n    \"\"\"draw vehicles routings\n    adapted from https://stackoverflow.com/a/50682819\n    \n    examples:\n    locations = {\n        0: (5, 5),\n        1: (4, 9),\n        2: (6, 4),\n        3: (2, 6),\n    }\n\n    edges = [\n        (0, 1, {'vehicle': '0'}),\n        (1, 2, {'vehicle': '0'}),\n        (2, 0, {'vehicle': '0'}),\n        (0, 3, {'vehicle': '1'}),\n        (3, 0, {'vehicle': '1'}),\n    ]\n\n    Args:\n        locations (dict): location id -&gt; (lat, lon)\n        edges (list): list of edges\n    \"\"\"\n    G = nx.DiGraph()\n    G.add_edges_from(edges)\n    plt.figure(figsize=(15,10))\n    \n    vehicles = set([e[2]['vehicle'] for e in edges])\n    num_vehicles = len(vehicles)\n    \n    colors = mpl.colormaps[\"Set1\"].colors\n    for v in range(num_vehicles):\n        temp = [e for e in edges if e[2]['vehicle'] == str(v)]\n        \n        color_idx = v \n        if color_idx &gt;= len(colors):\n            color_idx = color_idx % len(colors)\n        color = np.array([colors[color_idx]])\n        \n        nx.draw_networkx_nodes(G, \n                                locations, \n                                nodelist=[x[0] for x in temp], \n                                node_color=color)\n        nx.draw_networkx_edges(G,\n                                locations, \n                                edgelist=temp,\n                                width=4, \n                                edge_color=color, \n                                style='dashed')\n\n    #let's color the node 0 in black\n    nx.draw_networkx_nodes(G, locations, \n                            nodelist=[0], \n                            node_color='k')\n\n    # labels\n    nx.draw_networkx_labels(G, locations, \n                            font_color='w', \n                            font_size=12, \n                            font_family='sans-serif')\n\n    #print out the graph\n    plt.axis('off')\n    plt.show()\n\nFigure 2.1 shows the optimal vehicle routes for the instance P-n16-k8.vrp.\n\n\nCode\n# visualize the optimal solution\nnode_coords = instance['node_coord']\nlocations = {}\nfor idx, coord in enumerate(node_coords):\n    locations[idx] = (coord[0], coord[1])\n\nroutes = solution['routes']\nvehicle_idx = 0\nedges = []\nfor route in routes:\n    r_temp = route.copy()\n    r_temp.insert(0, 0)\n    r_temp.insert(len(r_temp), 0)\n    for i in range(len(r_temp) - 1):\n        edges.append((r_temp[i], r_temp[i + 1], {'vehicle': str(vehicle_idx)}))\n    \n    vehicle_idx += 1\n\nshow_vehicle_routes(locations, edges)\n\n\n\n\n\n\n\n\nFigure 2.1: Optimal routes for instance P-n16-k8.vrp",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capacitated Vehicle Routing Problem</span>"
    ]
  },
  {
    "objectID": "ip-cvrp.html#two-index-formulation---1",
    "href": "ip-cvrp.html#two-index-formulation---1",
    "title": "2  Capacitated Vehicle Routing Problem",
    "section": "2.2 Two-index Formulation - 1",
    "text": "2.2 Two-index Formulation - 1\nThis formulation was proposed by Laporte, Mercure, and Nobert (1986) and we present the formulation given in Toth and Vigo (2014). In this formulation, we define the variable \\(x_{ij}\\) that equals 1 if the arc \\((i, j)\\) is traversed by a vehicle. The complete model is given below.\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{cvrp-two-index-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{j \\in \\delta^+(i)}x_{ij} = 1, \\ \\forall i \\in \\mathcal{N} \\label\n    {cvrp-two-index-cons1}\\\\\n    &\\quad \\sum_{i \\in \\delta^-(j)} x_{ij} = 1, \\ \\forall j \\in \\mathcal{N} \\label{cvrp-two-index-cons2} \\\\\n    &\\quad \\sum_{j \\in \\delta^+(0)} x_{oj} = |\\mathcal{K}| \\label{cvrp-two-index-cons3} \\\\\n    &\\quad \\sum_{(i, j) \\in \\delta^+(S)} x_{ij} \\geq r(S), \\ \\forall S \\subseteq \\mathcal{N}, S \\neq \\emptyset \\label{cvrp-two-index-cons4} \\\\\n    &\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{cvrp-two-index-cons5}\n\\end{align}\\]\nThe objective function represented by equation \\(\\eqref{cvrp-two-index-obj}\\) is to minimize the overall transportation costs. The constraints expressed in equations \\(\\eqref{cvrp-two-index-cons1}\\) and \\(\\eqref{cvrp-two-index-cons2}\\) work together to guarantee that each customer is visited only once, with one incoming and outgoing arc. Constraints \\(\\eqref{cvrp-two-index-cons3}\\) ensure that all available vehicles are utilized to serve the customers. Constraints \\(\\eqref{cvrp-two-index-cons4}\\) prevent the formation of sub-tours. Finally, the variable types are defined by the last set of constraints, which are presented in equation \\(\\eqref{cvrp-two-index-cons5}\\).\nTo solve the aforementioned instance, we’ll first prepare the data for our following implementation use. Let’s first define two classes, Node and Vehicle, to represent a node in the network and the vechiles, respectively.\n\nclass Node:\n    \"\"\"a node is either a depot (0) or a customer\n    \"\"\"\n    \n    def __init__(self, id, x_coord=0, y_coord=0, demand=0):\n        self._id = id\n        self._x_coord = x_coord\n        self._y_coord = y_coord\n        self._demand = demand\n        \n    @property\n    def id(self): return self._id\n    \n    @property\n    def x_coord(self): return self._x_coord\n    \n    @property\n    def y_coord(self): return self._y_coord\n    \n    @property\n    def demand(self): return self._demand\n    \n    def __str__(self):\n        return f\"id: {self._id},\\\n            x_coord: {self._x_coord},\\\n            y_coord: {self._y_coord},\\\n            demand: {self._demand}\"\n\n\nclass Vehicle:\n    \"\"\"a vehicle\n    \"\"\"\n    \n    def __init__(self, id, capacity):\n        self._id = id\n        self._capacity = capacity\n        \n    @property\n    def id(self): return self._id\n    \n    @property\n    def capacity(self): return self._capacity\n    \n    def __str__(self):\n        return f\"id: {self._id}, capacity: {self._capacity}\"\n\nNow let’s define a class CvrpDataCenter to hold all the information we need later. It also has a helper function to read and parse a CVRP instance.\n\nfrom typing import List\nimport vrplib\nimport re\nfrom itertools import combinations\n\nclass CvrpDataCenter:\n    \"\"\"this class manages all the data for a CVRP instance\n    \"\"\"\n    \n    def __init__(self):\n        self._nodes: List = None\n        self._vehicles: List = None\n        self._distance: List[List] = None\n\n    def read_cvrp_instance(self, instance_file):\n        \"\"\"read a given cvrp instance\n\n        Args:\n            instance_file (str): instance file\n        \"\"\"\n        instance = vrplib.read_instance(instance_file)\n\n        # gather nodes\n        nodes = []\n        idx = 0\n        if 'node_coord' in instance:\n            for node, demand in zip(instance['node_coord'], \n                                    instance['demand']):\n                node = Node(id=idx, \n                            x_coord=node[0], \n                            y_coord=node[1], \n                            demand=demand)\n                idx += 1\n                nodes.append(node)\n        else:\n            for demand in instance['demand']:\n                node = Node(id=idx, \n                            demand=demand)\n                idx += 1\n                nodes.append(node)\n            \n        # gather vehicles\n        comment = instance['comment']\n        num_vehicles = int(re.search(r'\\d', comment).group())\n        vehicles = []\n        for v in range(num_vehicles):\n            vehicle = Vehicle(v, int(instance['capacity']))\n            vehicles.append(vehicle)\n        \n        # gather distance matrix\n        distance = instance['edge_weight']\n        \n        self._nodes = nodes\n        self._vehicles = vehicles\n        self._distance = distance\n    \n    @property\n    def nodes(self): return self._nodes\n    \n    @property\n    def vehicles(self): return self._vehicles\n    \n    @property\n    def num_nodes(self): return len(self._nodes)\n    \n    @property\n    def num_vehicles(self): return len(self._vehicles)\n    \n    @property\n    def vehicle_capacity(self): \n        return self._vehicles[0].capacity\n\n    def distance(self, i, j, integer=False):\n        return round(self._distance[i][j]) \\\n            if integer else self._distance[i][j]\n    \n    def get_all_combinations(self, numbers):\n        combs = []\n        for i in range(1, len(numbers) + 1):\n            combs.extend(list(combinations(numbers, i)))\n        return combs\n\nTo implement this formulation using Google OR-Tools, we first create a CvrpDataCenter object and read in the instance P-n16-k8.vrp. Then we create a solver object with solver option SCIP to solve mixed integer programming problems.\n\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\nfrom itertools import product\nimport math\n\n# prepare instance\ncvrp_data_center = CvrpDataCenter()\ncvrp_data_center.read_cvrp_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\n\n# instantiate solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\nNow let’s create the decision variable \\(x_{ij}\\). Note that we don’t need to create variables when \\(i = j\\) since there is no arc pointing to itself in the graph \\(\\mathcal{G}\\) we defined earlier.\n\n# create decision variables\nnum_nodes = cvrp_data_center.num_nodes\nnum_vehicles = cvrp_data_center.num_vehicles\nvar_x = np.empty((num_nodes, num_nodes), dtype=object)\nfor i, j in product(range(num_nodes), range(num_nodes)):\n    if i == j: continue\n    var_x[i][j] = solver.BoolVar(name=\"x_{i, j}\")\n\nThen we create the objective function.\n\n# define objective function\nobj_expr = [\n    cvrp_data_center.distance(i, j, integer=True) * var_x[i][j]\n    for i, j in product(range(num_nodes), range(num_nodes))\n    if i != j\n]\nsolver.Minimize(solver.Sum(obj_expr))\n\nAnd we create the constraints \\(\\eqref{cvrp-two-index-cons1}\\) and \\(\\eqref{cvrp-two-index-cons2}\\).\n\n# create incoming and outgoing arc constraints\nfor i in range(1, num_nodes):\n    out_arcs = [var_x[i][j] for j in range(num_nodes) if j != i]\n    in_arcs = [var_x[j][i] for j in range(num_nodes) if j != i]\n    solver.Add(solver.Sum(out_arcs) == 1)\n    solver.Add(solver.Sum(in_arcs) == 1)\n\nConstraints \\(\\eqref{cvrp-two-index-cons3}\\) are created as follows.\n\n# create fleet size constraint\nexpr = [var_x[0][i] for i in range(1, num_nodes)]\nsolver.Add(solver.Sum(expr) == num_vehicles)\n\nTo create the subtour elimination constraints \\(\\eqref{cvrp-two-index-cons4}\\), we first need to enumerate all the non-empty subset of \\(\\mathcal{N}\\), for which we define a helper function named get_all_combinations() in the CvrpDataCenter class. In the code snippet below, we define a separate constraint for every nonempty customer set \\(S\\), and the right-hand side \\(r(S)\\) is defined as \\(\\lceil {q(S) / Q} \\rceil\\).\n\n# create subtour elimination constraint\nnodes = cvrp_data_center.nodes\nvehicle_capacity = cvrp_data_center.vehicle_capacity\ncustomer_ids = [node.id for node in nodes if node.id &gt; 0]\nnode_ids = [node.id for node in nodes]\nnonempty_customer_sets = cvrp_data_center.get_all_combinations(customer_ids)\nfor customer_set in nonempty_customer_sets:\n    others = set(node_ids).difference(customer_set)\n    expr = [var_x[i][j]\n            for i in customer_set\n            for j in others]\n    total_demand = sum([node.demand \n                        for node in nodes \n                        if node.id in set(customer_set)])\n    rhs = math.ceil(total_demand / vehicle_capacity)\n    solver.Add(solver.Sum(expr) &gt;= rhs)\n\nPutting it all together, we have the complete program below. It can be seen from the output that the optimal solution is 450 and there are 8 routes in the identified solution.\n\nfrom ortools.linear_solver import pywraplp\nimport numpy as np\nfrom itertools import product\nimport math\n\n# prepare instance\ncvrp_data_center = CvrpDataCenter()\ncvrp_data_center.read_cvrp_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\n\n# instantiate solver\nsolver = pywraplp.Solver.CreateSolver('SCIP')\n\n# create decision variables\nnum_nodes = cvrp_data_center.num_nodes\nnum_vehicles = cvrp_data_center.num_vehicles\nvar_x = np.empty((num_nodes, num_nodes), dtype=object)\nfor i, j in product(range(num_nodes), range(num_nodes)):\n    if i == j: continue\n    var_x[i][j] = solver.BoolVar(name=\"x_{i, j}\")\n\n# define objective function\nobj_expr = [\n    cvrp_data_center.distance(i, j, integer=True) * var_x[i][j]\n    for i, j in product(range(num_nodes), range(num_nodes))\n    if i != j\n]\nsolver.Minimize(solver.Sum(obj_expr))\n\n# create incoming and outgoing arc constraints\nfor i in range(1, num_nodes):\n    out_arcs = [var_x[i][j] for j in range(num_nodes) if j != i]\n    in_arcs = [var_x[j][i] for j in range(num_nodes) if j != i]\n    solver.Add(solver.Sum(out_arcs) == 1)\n    solver.Add(solver.Sum(in_arcs) == 1)\n\n# create fleet size constraint\nexpr = [var_x[0][i] for i in range(1, num_nodes)]\nsolver.Add(solver.Sum(expr) == num_vehicles)\n\n# create subtour elimination constraint\nnodes = cvrp_data_center.nodes\nvehicle_capacity = cvrp_data_center.vehicle_capacity\ncustomer_ids = [node.id for node in nodes if node.id &gt; 0]\nnode_ids = [node.id for node in nodes]\nnonempty_customer_sets = cvrp_data_center.get_all_combinations(customer_ids)\nfor customer_set in nonempty_customer_sets:\n    others = set(node_ids).difference(customer_set)\n    expr = [var_x[i][j]\n            for i in customer_set\n            for j in others]\n    total_demand = sum([node.demand \n                        for node in nodes \n                        if node.id in set(customer_set)])\n    rhs = math.ceil(total_demand / vehicle_capacity)\n    solver.Add(solver.Sum(expr) &gt;= rhs)\n    \nstatus = solver.Solve()\nif not status:\n    opt_obj = solver.Objective().Value()\n    \n    opt_x = np.zeros((num_nodes, num_nodes))\n    for i, j in product(range(num_nodes), range(num_nodes)):\n        if i == j: continue\n        opt_x[i][j] = int(var_x[i][j].solution_value())\n\n    routes = []\n    for i in range(1, num_nodes):\n        if opt_x[0][i] == 0: continue\n        # new route found\n        route = []\n        \n        route_length = 0\n        # add the first arc\n        arc_start = 0\n        arc_end = i\n        route.append((arc_start, arc_end))\n        route_length += cvrp_data_center.distance(arc_start, \n                                                arc_end, \n                                                integer=True)\n        \n        # add remaining arcs on the route\n        arc_start = arc_end\n        while True:\n            for j in range(num_nodes):\n                if opt_x[arc_start][j] == 1:\n                    arc_end = j\n                    break\n            route.append((arc_start, arc_end))\n            route_length += cvrp_data_center.distance(arc_start, \n                                                    arc_end, \n                                                    integer=True)\n            if arc_end == 0: break\n            arc_start = arc_end\n\n        routes.append(route)\n\nTo facilitate the model comparison in following steps, we’ll wrap the above program into a dedicated class Cvrp1.\n\nfrom ortools.linear_solver import pywraplp\nfrom itertools import product\nimport numpy as np\nimport math\n\nclass Cvrp1:\n    \"\"\"solve the cvrp model using the two index formulation\n    \"\"\"\n\n    def __init__(self, cvrp_data_center: CvrpDataCenter):\n        self._data_center: CvrpDataCenter = cvrp_data_center\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        \n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_routes = None\n    \n    def read_instance(self, instance_file):\n        self._data_center.read_cvrp_instance(instance_file)\n\n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_constr_flow()\n        self._create_constr_fleet()\n        self._create_constr_subtour()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        if not status:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_routes()\n    \n    def _create_variables(self):\n        num_nodes = self._data_center.num_nodes\n        self._var_x = np.empty((num_nodes, num_nodes), dtype=object)\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._var_x[i][j] = self._solver.BoolVar(name=\"x_{i, j}\")\n\n    def _create_objective(self):\n        num_nodes = self._data_center.num_nodes\n        obj_expr = [\n            self._data_center.distance(i, j, integer=True) * \n                self._var_x[i][j]\n                for i, j in product(range(num_nodes), range(num_nodes))\n                if i != j\n        ]\n        self._solver.Minimize(self._solver.Sum(obj_expr))\n            \n    def _create_constr_flow(self):\n        # create incoming and outgoing arc constraints\n        num_nodes = self._data_center.num_nodes\n        for i in range(1, num_nodes):\n            out_arcs = [self._var_x[i][j] for j in range(num_nodes) if j != i]\n            in_arcs = [self._var_x[j][i] for j in range(num_nodes) if j != i]\n            self._solver.Add(self._solver.Sum(out_arcs) == 1)\n            self._solver.Add(self._solver.Sum(in_arcs) == 1)\n            \n    def _create_constr_fleet(self):\n        # create fleet size constraint\n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        expr = [self._var_x[0][i] for i in range(1, num_nodes)]\n        self._solver.Add(self._solver.Sum(expr) == num_vehicles)\n    \n    def _create_constr_subtour(self):\n        # create subtour elimination constraint\n        nodes = self._data_center.nodes\n        vehicle_capacity = self._data_center.vehicle_capacity\n        customer_ids = [node.id for node in nodes if node.id &gt; 0]\n        node_ids = [node.id for node in nodes]\n        nonempty_customer_sets = self._data_center.get_all_combinations(customer_ids)\n        for customer_set in nonempty_customer_sets:\n            others = set(node_ids).difference(customer_set)\n            expr = [self._var_x[i][j]\n                    for i in customer_set\n                    for j in others]\n            total_demand = sum([node.demand \n                                for node in nodes \n                                if node.id in set(customer_set)])\n            rhs = math.ceil(total_demand / vehicle_capacity)\n            self._solver.Add(self._solver.Sum(expr) &gt;= rhs)\n        print(f\"No. subtour elimination constraints: {len(nonempty_customer_sets)}\")\n    \n    def show_model_summary(self):\n        print(f\"No. of variables: {self._solver.NumVariables()}\")\n        print(f\"No. of constraints: {self._solver.NumConstraints()}\")\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = self._solver.Objective().Value()\n        print(f'Optimal value: {self._opt_obj:.2f}')\n        \n        num_nodes = self._data_center.num_nodes\n        self._opt_x = np.zeros((num_nodes, num_nodes))\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._opt_x[i][j] = int(self._var_x[i][j].solution_value())\n\n    def _retrieve_opt_routes(self):\n        num_nodes = self._data_center.num_nodes\n        self._routes = []\n        for i in range(1, num_nodes):\n            if self._opt_x[0][i] == 0: continue\n            # new route found\n            route = []\n            \n            route_length = 0\n            # add the first arc\n            arc_start = 0\n            arc_end = i\n            route.append((arc_start, arc_end))\n            route_length += self._data_center\\\n                    .distance(arc_start, \n                            arc_end,\n                            integer=True)\n            \n            # add remaining arcs on the route\n            arc_start = arc_end\n            while True:\n                for j in range(num_nodes):\n                    if self._opt_x[arc_start][j] == 1:\n                        arc_end = j\n                        break\n                route.append((arc_start, arc_end))\n                route_length += self._data_center\\\n                    .distance(arc_start,\n                            arc_end,\n                            integer=True)\n                if arc_end == 0: break\n                arc_start = arc_end\n\n            self._routes.append(route)\n            print(f'route: {route}, length: {route_length}')\n    \n    def show_opt_routes(self):\n        nodes = self._data_center.nodes\n        locations = {\n            node.id: (node.x_coord, node.y_coord)\n            for node in nodes\n        }\n\n        edges = []\n        vehicle_idx = 0\n        for route in self._routes:\n            for arc in route:\n                edges.append((arc[0], arc[1], {'vehicle': str(vehicle_idx)}))\n            vehicle_idx += 1\n        edges\n\n        show_vehicle_routes(locations, edges)\n\nThe code below validates that the same optimal solution is obtained using this object-oriented approach. Figure 2.2 shows the routes found by the two-index formulation. Note that the routes are different from the ones in Figure 2.1 but they have the same objective value.\n\n\nCode\ncvrp1 = Cvrp1(CvrpDataCenter())\ncvrp1.read_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\ncvrp1.build_model()\ncvrp1.show_model_summary()\ncvrp1.optimize()\ncvrp1.show_opt_routes()\n\n\nNo. subtour elimination constraints: 2047\nNo. of variables: 132\nNo. of constraints: 2070\nOptimal value: 347.00\nroute: [(0, 1), (1, 3), (3, 0)], length: 66\nroute: [(0, 2), (2, 0)], length: 42\nroute: [(0, 4), (4, 10), (10, 0)], length: 55\nroute: [(0, 5), (5, 9), (9, 7), (7, 0)], length: 68\nroute: [(0, 6), (6, 0)], length: 24\nroute: [(0, 8), (8, 11), (11, 0)], length: 92\n\n\n\n\n\n\n\n\nFigure 2.2: Optimal routes found by the two-index formulation\n\n\n\n\n\nIt can be seen from the model output that there are a total of 32798 constraints, out of which 32767 are subtour elimination constraints, even for such a small instance with only 15 customers. In the next section, we will present another two index formulation to handle this exponential number of constraints.",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capacitated Vehicle Routing Problem</span>"
    ]
  },
  {
    "objectID": "ip-cvrp.html#two-index-formulation---2",
    "href": "ip-cvrp.html#two-index-formulation---2",
    "title": "2  Capacitated Vehicle Routing Problem",
    "section": "2.3 Two-index Formulation - 2",
    "text": "2.3 Two-index Formulation - 2\nThis formulation is based on the MTZ-model introduced by Miller, Tucker, and Zemlin (1960) for the TSP. To eliminate subtours, a new variable \\(u_i\\) is defined for every node \\(i \\in \\mathcal{N}\\):\n\n\\(u_i\\): the total demands distributed by any vehicle when it arrives at node \\(i\\)\n\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ij} \\label{cvrp2-obj} \\\\\n    \\text{s.t.} &\\quad \\sum_{j \\in \\delta^+(i)}x_{ij} = 1, \\ \\forall i \\in \\mathcal{N} \\label\n    {cvrp2-cons1}\\\\\n    &\\quad \\sum_{i \\in \\delta^-(j)} x_{ij} = 1, \\ \\forall j \\in \\mathcal{N} \\label{cvrp2-cons2} \\\\\n    &\\quad \\sum_{j \\in \\delta^+(0)} x_{oj} = |\\mathcal{K}| \\label{cvrp2-cons3} \\\\\n    &\\quad u_i \\leq u_j - q_j + Q(1 - x_{ij}), \\ \\forall (i, j) \\in \\mathcal{A}, i, j \\in \\mathcal{N} \\label{cvrp2-cons4}\\\\\n    &\\quad q_i \\leq u_i \\leq Q, \\ \\forall i \\in \\mathcal{N} \\label{cvrp2-cons5} \\\\\n    &\\quad x_{ij} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A} \\label{cvrp2-cons6}\n\\end{align}\\]\n\nfrom ortools.linear_solver import pywraplp\nfrom itertools import product\nimport numpy as np\n\nclass Cvrp2:\n    \"\"\"solve the cvrp model using the two index formulation\n    \"\"\"\n\n    def __init__(self, cvrp_data_center: CvrpDataCenter):\n        self._data_center: CvrpDataCenter = cvrp_data_center\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_u = None\n        \n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_routes = None\n    \n    def read_instance(self, instance_file):\n        self._data_center.read_cvrp_instance(instance_file)\n\n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_constr_flow()\n        self._create_constr_fleet()\n        self._create_constr_subtour()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        if not status:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_routes()\n    \n    def _create_variables(self):\n        num_nodes = self._data_center.num_nodes\n        self._var_x = np.empty((num_nodes, num_nodes), dtype=object)\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._var_x[i][j] = self._solver.BoolVar(name=\"x_{i, j}\")\n            \n        self._var_u = np.empty(num_nodes, dtype=object)\n        nodes = self._data_center.nodes\n        vehicle_capacity = float(self._data_center.vehicle_capacity)\n        for node in nodes:\n            if node.id == 0: continue\n            self._var_u[node.id] = self._solver.NumVar(\n                lb=float(node.demand), \n                ub=vehicle_capacity,\n                name='v')\n\n    def _create_objective(self):\n        num_nodes = self._data_center.num_nodes\n        obj_expr = [\n            self._data_center.distance(i, j, integer=True) * \n                self._var_x[i][j]\n                for i, j in product(range(num_nodes), range(num_nodes))\n                if i != j\n        ]\n        self._solver.Minimize(self._solver.Sum(obj_expr))\n            \n    def _create_constr_flow(self):\n        # create incoming and outgoing arc constraints\n        num_nodes = self._data_center.num_nodes\n        for i in range(1, num_nodes):\n            out_arcs = [self._var_x[i][j] for j in range(num_nodes) if j != i]\n            in_arcs = [self._var_x[j][i] for j in range(num_nodes) if j != i]\n            self._solver.Add(self._solver.Sum(out_arcs) == 1)\n            self._solver.Add(self._solver.Sum(in_arcs) == 1)\n            \n    def _create_constr_fleet(self):\n        # create fleet size constraint\n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        expr = [self._var_x[0][i] for i in range(1, num_nodes)]\n        self._solver.Add(self._solver.Sum(expr) == num_vehicles)\n    \n    def _create_constr_subtour(self):\n        # create subtour elimination constraint\n        constraints = []\n        nodes = self._data_center.nodes\n        vehicle_capacity = self._data_center.vehicle_capacity\n        for ni, nj in product(nodes, nodes):\n            if ni.id == 0 or nj.id == 0: continue\n            if ni.id == nj.id: continue\n            constr = self._solver.Add(\n                self._var_u[ni.id] &lt;=\n                self._var_u[nj.id] -\n                nj.demand +\n                vehicle_capacity * (\n                    1 - self._var_x[ni.id][nj.id]\n                )\n            )\n            constraints.append(constr)\n\n        print(f\"No. subtour elimination constraints: {len(constraints)}\")\n    \n    def show_model_summary(self):\n        print(f\"No. of variables: {self._solver.NumVariables()}\")\n        print(f\"No. of constraints: {self._solver.NumConstraints()}\")\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = self._solver.Objective().Value()\n        print(f'Optimal value: {self._opt_obj:.2f}')\n        \n        num_nodes = self._data_center.num_nodes\n        self._opt_x = np.zeros((num_nodes, num_nodes))\n        for i, j in product(range(num_nodes), range(num_nodes)):\n            if i == j: continue\n            self._opt_x[i][j] = int(self._var_x[i][j].solution_value())\n\n    def _retrieve_opt_routes(self):\n        num_nodes = self._data_center.num_nodes\n        self._routes = []\n        for i in range(1, num_nodes):\n            if self._opt_x[0][i] == 0: continue\n            # new route found\n            route = []\n            \n            route_length = 0\n            # add the first arc\n            arc_start = 0\n            arc_end = i\n            route.append((arc_start, arc_end))\n            route_length += self._data_center\\\n                    .distance(arc_start, \n                            arc_end,\n                            integer=True)\n            \n            # add remaining arcs on the route\n            arc_start = arc_end\n            while True:\n                for j in range(num_nodes):\n                    if self._opt_x[arc_start][j] == 1:\n                        arc_end = j\n                        break\n                route.append((arc_start, arc_end))\n                route_length += self._data_center\\\n                    .distance(arc_start,\n                            arc_end,\n                            integer=True)\n                if arc_end == 0: break\n                arc_start = arc_end\n\n            self._routes.append(route)\n            print(f'route: {route}, length: {route_length}')\n    \n    def show_opt_routes(self):\n        nodes = self._data_center.nodes\n        locations = {\n            node.id: (node.x_coord, node.y_coord)\n            for node in nodes\n        }\n\n        edges = []\n        vehicle_idx = 0\n        for route in self._routes:\n            for arc in route:\n                edges.append((arc[0], arc[1], {'vehicle': str(vehicle_idx)}))\n            vehicle_idx += 1\n        edges\n\n        show_vehicle_routes(locations, edges)\n\n\ncvrp2 = Cvrp2(CvrpDataCenter())\ncvrp2.read_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\ncvrp2.build_model()\ncvrp2.show_model_summary()\ncvrp2.optimize()\ncvrp2.show_opt_routes()\n\nNo. subtour elimination constraints: 110\nNo. of variables: 143\nNo. of constraints: 133\nOptimal value: 347.00\nroute: [(0, 1), (1, 3), (3, 0)], length: 66\nroute: [(0, 2), (2, 0)], length: 42\nroute: [(0, 5), (5, 9), (9, 7), (7, 0)], length: 68\nroute: [(0, 6), (6, 0)], length: 24\nroute: [(0, 10), (10, 4), (4, 0)], length: 55\nroute: [(0, 11), (11, 8), (8, 0)], length: 92",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capacitated Vehicle Routing Problem</span>"
    ]
  },
  {
    "objectID": "ip-cvrp.html#three-index-formulation",
    "href": "ip-cvrp.html#three-index-formulation",
    "title": "2  Capacitated Vehicle Routing Problem",
    "section": "2.4 Three-index Formulation",
    "text": "2.4 Three-index Formulation\nThis formulation is also known as the MTZ-formulation as a new set of constraints initially proposed for traveling salesman problem (Miller, Tucker, and Zemlin (1960)) is used to eliminate subtours.\nWe define the following variables in this formualation:\n\n\\(x_{ijk}\\): a binary variable that equals 1 when the vehicle \\(k\\) visits arc \\((i, j) \\in \\mathcal{A}\\), 0 otherwise\n\\(y_{ik}\\): a binary variable that equals 1 if node \\(i\\) is visited by vehicle \\(k\\), 0 otherwise\n\\(u_{ik}\\): a continuous variable that represents the demands delivered by vehicle \\(k\\) when arriving at node \\(i\\)\n\n\\[\\begin{align}\n    \\text{min.} &\\quad \\sum_{k \\in \\mathcal{K}} \\sum_{(i, j) \\in \\mathcal{A}} c_{ij} x_{ijk} \\label{cvrp3-obj} \\\\\n    \\text{s.t.} &\\quad x_{iik} = 0, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\\\\n    &\\quad \\sum_{j \\in \\mathcal{V}}x_{ijk} = \\sum_{j \\in \\mathcal{V}}x_{jik}, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\label{cvrp3-cons3} \\\\\n    &\\quad \\sum_{k \\in \\mathcal{K}} y_{ik} = 1, \\ \\forall i \\in \\mathcal{N} \\label{cvrp3-cons1} \\\\\n    &\\quad y_{ik} = \\sum_{j \\in \\mathcal{V}} x_{ijk}, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\label{cvrp3-cons4} \\\\\n    &\\quad y_{0k} = 1, \\ \\forall k \\in \\mathcal{K} \\\\\n    &\\quad u_{i} \\leq u_{j} - q_j + Q(1 - x_{ijk}), \\ \\forall i \\neq j, i, j \\in \\mathcal{N}, k \\in \\mathcal{K} \\label{cvrp3-cons6} \\\\\n    &\\quad q_i \\leq u_{i} \\leq Q, \\ \\forall i \\in \\mathcal{N}\\label{cvrp-cons7}\\\\\n    &\\quad x_{ijk} \\in \\{0, 1\\}, \\ \\forall (i, j) \\in \\mathcal{A}, k \\in \\mathcal{K} \\label{cvrp3-cons8} \\\\\n    &\\quad y_{ik} \\in \\{0, 1\\}, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\label{cvrp3-cons9} \\\\\n    &\\quad u_{ik} \\geq 0, \\ \\forall i \\in \\mathcal{V}, k \\in \\mathcal{K} \\label{cvrp3-cons10}\n\\end{align}\\]\n\nfrom ortools.linear_solver import pywraplp\nfrom itertools import product\nimport numpy as np\n\nclass Cvrp3:\n    \"\"\"solve the cvrp model using the two index formulation\n    \"\"\"\n\n    def __init__(self, cvrp_data_center: CvrpDataCenter):\n        self._data_center: CvrpDataCenter = cvrp_data_center\n        self._solver = pywraplp.Solver.CreateSolver('SCIP')\n        self._var_x = None\n        self._var_y = None\n        self._var_u = None\n        \n        self._opt_obj = None\n        self._opt_x = None\n        self._opt_routes = None\n    \n    def read_instance(self, instance_file):\n        self._data_center.read_cvrp_instance(instance_file)\n\n    def build_model(self):\n        self._create_variables()\n        self._create_objective()\n        self._create_constr_flow()\n        self._create_constr_customer_must_be_visited()\n        self._create_constr_subtour()\n        \n    def optimize(self):\n        status = self._solver.Solve()\n        print(\"solve complete!\")\n        if not status:\n            self._retrieve_opt_solution()\n            self._retrieve_opt_routes()\n        else:\n            print(f\"status={status}\")\n    \n    def _create_variables(self):\n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        self._var_x = np.empty((num_vehicles, num_nodes, num_nodes), \n                            dtype=object)\n        for k, i, j in product(range(num_vehicles), \n                            range(num_nodes),\n                            range(num_nodes)):\n            self._var_x[k][i][j] = self._solver.BoolVar(name=f\"x_{k, i, j}\")\n            \n        self._var_y = np.empty((num_vehicles, num_nodes), dtype=object)\n        for k, i in product(range(num_vehicles),\n                            range(num_nodes)):\n            self._var_y[k][i] = self._solver.BoolVar(name=f'y_{k, i}')\n        \n        vehicle_capacity = self._data_center.vehicle_capacity\n        self._var_u = np.empty(num_nodes, dtype=object)\n        for node in self._data_center.nodes:\n            self._var_u[node.id] = self._solver.NumVar(\n                float(node.demand),\n                vehicle_capacity,\n                name=f'u_{node.id}')\n\n    def _create_objective(self):\n        num_vehicles = self._data_center.num_vehicles\n        num_nodes = self._data_center.num_nodes\n        obj_expr = [\n            self._data_center.distance(i, j, integer=True) * \n                self._var_x[k][i][j]\n                for k, i, j in product(range(num_vehicles), range(num_nodes), range(num_nodes))\n                if i != j\n        ]\n        self._solver.Minimize(self._solver.Sum(obj_expr))\n    \n    def _create_constr_flow(self):\n        # create incoming and outgoing arc constraints\n        num_vehicles = self._data_center.num_vehicles\n        num_nodes = self._data_center.num_nodes\n        for k, i in product(range(num_vehicles),\n                            range(num_nodes)):\n            self._solver.Add(self._var_x[k][i][i] == 0)\n            \n        for k, i in product(range(num_vehicles),\n                            range(num_nodes)):\n            expr1 = [self._var_x[k][i][j] for j in range(num_nodes)]\n            expr2 = [self._var_x[k][j][i] for j in range(num_nodes)]\n            self._solver.Add(self._solver.Sum(expr1) == \n                            self._solver.Sum(expr2))\n    \n    def _create_constr_customer_must_be_visited(self):\n        num_vehicles = self._data_center.num_vehicles\n        num_nodes = self._data_center.num_nodes\n        for i in range(1, num_nodes):\n            expr = [self._var_y[k][i] for k in range(num_vehicles)]\n            self._solver.Add(self._solver.Sum(expr) == 1)\n        \n        for k, i in product(range(num_vehicles),\n                            range(num_nodes)):\n            expr = [self._var_x[k][i][j] for j in range(num_nodes)]\n            self._solver.Add(self._solver.Sum(expr) ==\n                            self._var_y[k][i])\n        \n        for k in range(num_vehicles):\n            self._solver.Add(self._var_y[k][0] == 1)\n\n    def _create_constr_subtour(self):\n        # create subtour elimination constraint\n        constraints = []\n        nodes = self._data_center.nodes\n        vehicle_capacity = self._data_center.vehicle_capacity\n        num_vehicles = self._data_center.num_vehicles\n        for k, ni, nj in product(range(num_vehicles), nodes, nodes):\n            if ni.id == 0 or nj.id == 0: continue\n            if ni.id == nj.id: continue\n            constr = self._solver.Add(self._var_u[ni.id] &lt;=\n                    self._var_u[nj.id] -\n                    float(nj.demand) +\n                    vehicle_capacity * (\n                        1 - self._var_x[k][ni.id][nj.id]\n                    )\n                )\n            constraints.append(constr)\n\n        print(f\"No. subtour elimination constraints: {len(constraints)}\")\n    \n    def show_model_summary(self):\n        print(f\"No. of variables: {self._solver.NumVariables()}\")\n        print(f\"No. of constraints: {self._solver.NumConstraints()}\")\n    \n    def _retrieve_opt_solution(self):\n        self._opt_obj = self._solver.Objective().Value()\n        print(f'Optimal value: {self._opt_obj:.2f}')\n        \n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        self._opt_x = np.zeros((num_vehicles, num_nodes, num_nodes))\n        for k, i, j in product(range(num_vehicles), range(num_nodes), range(num_nodes)):\n            self._opt_x[k][i][j] = int(self._var_x[k][i][j].solution_value())\n\n    def _retrieve_opt_routes(self):\n        num_nodes = self._data_center.num_nodes\n        num_vehicles = self._data_center.num_vehicles\n        self._routes = []\n        for k in range(num_vehicles):     \n            route = []   \n            for i in range(1, num_nodes):\n                if self._opt_x[k][0][i] == 0: continue\n\n                # new route found\n                route_length = 0\n                # add the first arc\n                arc_start = 0\n                arc_end = i\n                route.append((arc_start, arc_end))\n                route_length += self._data_center\\\n                        .distance(arc_start, \n                                arc_end,\n                                integer=True)\n                \n                # add remaining arcs on the route\n                arc_start = arc_end\n                while True:\n                    for j in range(num_nodes):\n                        if self._opt_x[k][arc_start][j] == 1:\n                            arc_end = j\n                            break\n                    route.append((arc_start, arc_end))\n                    route_length += self._data_center\\\n                        .distance(arc_start,\n                                arc_end,\n                                integer=True)\n                    if arc_end == 0: break\n                    arc_start = arc_end\n\n                self._routes.append(route)\n                print(f'route: {route}, length: {route_length}')\n                \n                break\n    \n    def show_opt_routes(self):\n        nodes = self._data_center.nodes\n        locations = {\n            node.id: (node.x_coord, node.y_coord)\n            for node in nodes\n        }\n\n        edges = []\n        vehicle_idx = 0\n        for route in self._routes:\n            for arc in route:\n                edges.append((arc[0], arc[1], {'vehicle': str(vehicle_idx)}))\n            vehicle_idx += 1\n        edges\n\n        show_vehicle_routes(locations, edges)\n\n\ncvrp3 = Cvrp3(CvrpDataCenter())\ncvrp3.read_instance(\"./data/cvrp/P-n16-k8-mini.vrp\")\ncvrp3.build_model()\ncvrp3.show_model_summary()\ncvrp3.optimize()\ncvrp3.show_opt_routes()\n\nNo. subtour elimination constraints: 660\nNo. of variables: 948\nNo. of constraints: 893\nsolve complete!\nOptimal value: 347.00\nroute: [(0, 3), (3, 1), (1, 0)], length: 66\nroute: [(0, 2), (2, 0)], length: 42\nroute: [(0, 7), (7, 9), (9, 5), (5, 0)], length: 68\nroute: [(0, 8), (8, 11), (11, 0)], length: 92\nroute: [(0, 4), (4, 10), (10, 0)], length: 55\nroute: [(0, 6), (6, 0)], length: 24",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capacitated Vehicle Routing Problem</span>"
    ]
  },
  {
    "objectID": "ip-cvrp.html#performance-comparison",
    "href": "ip-cvrp.html#performance-comparison",
    "title": "2  Capacitated Vehicle Routing Problem",
    "section": "2.5 Performance Comparison",
    "text": "2.5 Performance Comparison\nTable 2.1 shows the runtime comparison on the same instance.\n\n\n\n\nTable 2.1: Computational time comparison of the three formulations\n\n\n\n\n\n\nInstance\nModel 1\nModel 2\nModel 3\n\n\n\n\nP-n12-k8-mini.vrp\n0.4s\n0.3s\n1m5s\n\n\n\n\n\n\n\n\n\n\n\n\nCVRPLIB. 2014. “CVRPLIB.” http://vrp.galgos.inf.puc-rio.br/index.php/en/.\n\n\nLaporte, Gilbert, Hélène Mercure, and Yves Nobert. 1986. “An Exact Algorithm for the Asymmetrical Capacitated Vehicle Routing Problem.” Networks 16 (1): 33–46. https://doi.org/10.1002/net.3230160104.\n\n\nMiller, C. E., A. W. Tucker, and R. A. Zemlin. 1960. “Integer Programming Formulation of Traveling Salesman Problems.” Journal of the ACM 7 (4): 326–29. https://doi.org/10.1145/321043.321046.\n\n\nToth, Paolo, and Daniele Vigo. 2014. Vehicle Routing: Problems, Methods, and Applications. SIAM.",
    "crumbs": [
      "Exact Algorithms",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Capacitated Vehicle Routing Problem</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "10  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Summary</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "CVRPLIB. 2014. “CVRPLIB.” http://vrp.galgos.inf.puc-rio.br/index.php/en/.\n\n\nDantzig, G., R. Fulkerson, and S. Johnson. 1954. “Solution of a\nLarge-Scale\nTraveling-Salesman\nProblem.” Journal of the Operations Research\nSociety of America 2 (4): 393–410. https://doi.org/10.1287/opre.2.4.393.\n\n\nLaporte, Gilbert, Hélène Mercure, and Yves Nobert. 1986. “An Exact\nAlgorithm for the Asymmetrical Capacitated Vehicle Routing\nProblem.” Networks 16 (1): 33–46. https://doi.org/10.1002/net.3230160104.\n\n\nMiller, C. E., A. W. Tucker, and R. A. Zemlin. 1960. “Integer\nProgramming Formulation of\nTraveling Salesman\nProblems.” Journal of the ACM 7 (4):\n326–29. https://doi.org/10.1145/321043.321046.\n\n\nToth, Paolo, and Daniele Vigo. 2014. Vehicle Routing: Problems,\nMethods, and Applications. SIAM.",
    "crumbs": [
      "References"
    ]
  }
]